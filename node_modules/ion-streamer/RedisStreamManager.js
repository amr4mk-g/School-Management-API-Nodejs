const utils = require('./utils');
const debug = require('debug')('ion-streamer');
const {nanoid} = require('nanoid');
var NanoTimer = require('nanotimer');

const keyCheck = (key) => {
    if (!key) throw Error('Cache Key is missing');
}

module.exports = class RedisStreamManager {

    constructor({ url, prefix, activeDelay, idleDelay }){
        if (!prefix || !url) throw Error('missing in memory arguments');
    
        /** creating inmemory client */
        this.redisClient = require('./connect').createClient({
            prefix, url
        });
        this.prefix      = prefix;
        this.url         = url;
        this.prevId      = null;
        this.nextId      = null;
        this.id          = nanoid(8);
        this.delayTimer  = new NanoTimer();
        this.idleDelay   = idleDelay != 'null' ? idleDelay : "50m";
        this.activeDelay = activeDelay != 'null' ? activeDelay : "10m";
        
        this.log(this.id);
    }

    log(msg){
        debug(this.id + " : " + msg);
    }

    async asyncDelay(time){
        return new Promise((resolve, reject)=>{
            try{
                this.delayTimer.setTimeout(()=>{
                    resolve(true);
                },'', time)
            } catch(e) {
                console.log(e);
                reject({error: true});
            }
        })
    }

    delay(time, cb){
        this.delayTimer.setTimeout(()=>{
            try{
                cb();
            } catch (err){
                console.log('Callback failed to execute')
                console.log(err)
            }
        }, '', time);
    }

    async listenToStream({key, id="$", onData}){
        debug('.');
        keyCheck(key);
        /** same id has been already consumed */
        if(this.prevId == id) {
            await this.asyncDelay(this.idleDelay);
            return await this.listenToStream({key, id, onData});
        }
        
        const newKey = this.prefix+":"+key;
        let command = '';
        let startId = null;
        let endId = null;
        let count = 1;
        let args = null;
        
        if(id=="$"){
            //first time call
            command = 'XREVRANGE';
            startId = '+';
            endId   = '-';
            count   = 100;
            args    = [ command, newKey, startId, endId, 'COUNT', count];
        } else {
            command = 'XRANGE';
            startId = id;
            endId   = '+';
            args    = [ command, newKey, startId, endId];

        }

        let result = null;
        try {
            result = await this.redisClient.call(...args);
            if(!result || !Array.isArray(result)) return;
            let queue = result.map(message => {
                let p = {
                    id:message[0],
                    value:utils.flatArrToObject(message[1]),
                }
                onData(p);
                return p;
            });
           
            let lastId = (queue.length>0)?queue[queue.length-1].id:null;
            if(queue.length>0 && lastId) {
                let lastIdFrags = lastId.split('-');
                this.nextId = lastIdFrags[0]+"-"+(parseInt(lastIdFrags[1])+1);
                this.prevId = lastId;
            } else {
                await this.asyncDelay(this.idleDelay);
                this.nextId = id;
            }
        } catch(err){
            console.log(err);
        }
        this.delay(this.activeDelay, ()=>{
            this.listenToStream({key, id: this.nextId, onData}).catch(err=>console.log(err));;
        })
        return;
    }
    async emitToStream({key, json, maxLen}){

        keyCheck(key);
        key = this.prefix+":"+key;
        
        let flatten = utils.flattenObject(json);
        if(flatten.length==0)return;
        let args = [key];
        if(maxLen)args=args.concat(['MAXLEN', maxLen]);
        args.push('*')
        args = args.concat(flatten);

        try {
            await this.redisClient.call('XADD', ...args);
        } catch(err){
            debug(err);
        }

    }

}

