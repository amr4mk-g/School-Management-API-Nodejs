const prefix           = process.env.ION_SL_PREFIX;
const url              = process.env.ION_SL_URL;
const key              = process.env.ION_SL_KEY;
const block            = process.env.ION_SL_BLOCK || 0;
const idleDelay        = process.env.ION_IDLE_DELAY;
const activeDelay      = process.env.ION_ACTIVE_DELAY;
const debug            = require('debug')('ion-streamer');

let streamCli          = {};


//check if arugment is passed correctly 
if(!prefix || !url || !key) throw Error('missing arguments');

//load client for that specific event 
try{
    const RedisStreamManager = require('./RedisStreamManager.js');
    streamCli = new RedisStreamManager({url, prefix, idleDelay, activeDelay});
}catch(err){
    process.exit(1);
}

// SIGTERM AND SIGINT will trigger the exit event.
process.on("SIGTERM", function () {
    console.log('consumer process existed SIGTERM')
    process.exit(1);
});

process.on("SIGINT", function () {
    console.log('consumer process existed SIGINT')
    process.exit(1);
});

process.on('error', function (err) {
    console.log(err);
    process.exit(1);
});

process.on('uncaughtException', function (err) {
    // console.log(err);
    process.exit(1);
});


/** should keep running 4ever */
const run = async()=>{
    try {
        await streamCli.listenToStream({
            key,
            block,
            onData: (result)=>{
                try {
                    process.send(result);
                } catch(err){
                    console.log(err);
                }
            }
        });
    } catch(err){
        console.log(err);
    }
    return true;
    // if(result && result.id) {

    //     /** 
    //      * this keeps the queue sequence even if processes are delaying 
    //      * for example if there are too many events at the level of a millisecond 
    //      * the event will keep track by the last read and get the next one without skipping
    //      * any in sequence | | [|] the next will be -> | | not this-> |
    //      */
    //     //return run({id:result.id});
    //     return run({id:result.id});
    // } else {
    //     debug('malformed message received on listen pipe!', result);
    // }

}

run({});
debug(`listening for event: ${key}`);