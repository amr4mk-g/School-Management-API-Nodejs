
const emptyCb = ()=>{};
const path    = require('path');

class Consumer {
    constructor({prefix, url, key, block, keepAlive, onMessage, onError, onClose, activeDelay, idleDelay }){

        this.prefix        = prefix;
        this.url           = url; 
        this.key           = key;
        this.block         = block || 0 ;
        this.keepAlive     = keepAlive || false ;
        this.onMessage     = onMessage || emptyCb;
        this.onError       = onError || emptyCb;
        this.onClose       = onClose || emptyCb;
        this.child         = null;
        this.forcedToClose = false;
        this.idleDelay     = idleDelay;
        this.activeDelay   = activeDelay;

        this.fork();
        this.processEvents();

    }

    _faultHandler(){
        if(this.keepAlive && !this.forcedToClose){
            this.child.kill();
            setTimeout(()=>{this.fork()}, 1000);
        }
    }

    close(){
        this.forcedToClose = true;
        this.child.kill();
    }

    exitHandler(child, exitCode) {
        child.kill();
        process.exit();
    }

    processEvents(){
        process.on('exit', this.close.bind(this))
            .on('uncaughtException', this.close.bind(this))
            .on('SIGINT', this.close.bind(this))
            .on('SIGUSR1',  this.close.bind(this))
            .on('SIGUSR2',  this.close.bind(this))
    }

    fork() {
        this.child = require('child_process').fork(path.resolve(__dirname, './consumer-process.js'), {
            env: {
                ION_SL_PREFIX: this.prefix,
                ION_SL_URL: this.url,
                ION_SL_KEY: this.key,
                ION_SL_BLOCK: this.block,
                ION_IDLE_DELAY: this.idleDelay,
                ION_ACTIVE_DELAY: this.activeDelay
            }
        });
        
        this.child.on('message', this.onMessage);
        this.child.on('error', () => {
            this._faultHandler();
            this.onError();
        });
        this.child.on('close', () => {
            this._faultHandler();
            this.onClose();
        });

        this.child.on('exit', ()=> {
            this._faultHandler();
            this.onClose();
        })
    }
}

class Producer {
    constructor({prefix, url, activeDelay, idleDelay}){
        const RedisStreamManager = require('./RedisStreamManager')
        this.streamCli = new RedisStreamManager({url, prefix, activeDelay, idleDelay});
    }

    emit({data, key, maxLen}){
        this.streamCli.emitToStream({json:data, key, maxLen: maxLen||null}).catch(e => console.log(e));
    }
}


class StreamManager { 
    constructor({prefix, url}){
        if(!prefix || !url) throw Error(`prefix and url is missing`);
        this.prefix = prefix;
        this.url    = url;
    }
    consumer(args){
        return (new Consumer({prefix: this.prefix, url: this.url, ...args}))
    }
    producer(){
        return (new Producer({prefix: this.prefix, url: this.url}));
    }
}

module.exports = StreamManager
