
const NanoTimer = require('nanotimer');
const { createClient } = require("./connect")
const debug = require('debug')('Ion-SortedSet:RedisConsumer');

module.exports = class SortedSetConsumer {

	constructor({ url }) {
		this.redisClient = createClient({ url });
		this.timer = new NanoTimer();
		this.cleanerTimer = new NanoTimer();
		this.cleanUpDelay = 60;
		this.timestamp = null;
		this._redisPrefix = "scheduledTask"
	}

	async listenToSortedSet({ key, timestamp, onData, segmantDuration }) {
		this.timestamp = timestamp;
		try {
			if (Math.floor(timestamp) + 500 > Date.now()) {
				await this.delay(`${segmantDuration}m`);
				return this.listenToSortedSet({ key, timestamp, onData, segmantDuration })
			}
			const args = [key, timestamp, Math.floor(timestamp) + Math.floor(segmantDuration), 'WITHSCORES'];
			const tasks = await this.redisClient.zrangebyscore(...args);
			if (tasks.length !== 0) {
				for (let i = 0; i < tasks.length; i += 2)
					onData({ id: tasks[i + 1], value: JSON.parse(tasks[i]) });
			}
			this.listenToSortedSet({ key, timestamp: Math.floor(timestamp) + Math.floor(segmantDuration) + 1, onData, segmantDuration });
		} catch (error) {
			debug('===> Error at listenToSortedSet <===', error);
		}
	}

	async setCleaner({ executionkey, key }) {
		const retries = [];
		const interval = 1000 * (this.cleanUpDelay / 2); //delays clean up for a minute, half here and half in the redis call
		await this.delayClean(`${interval}m`);
		const timestamp = Date.now()
		const args = [key, '-INF', timestamp - interval];
		const execArgs = [executionkey, '-INF', timestamp - interval];
		const orders = await this.redisClient.zrangebyscore(...args);
		const executedOrders = await this.redisClient.zrangebyscore(...execArgs);

		for (const order of orders) {
			if (!executedOrders.includes(order)) retries.push(order);
		}

		for (const retry of retries) {
			this.redisClient.zadd(key, Date.now() + 5000, retry);
		}
		this.redisClient.zremrangebyscore(...args);
		this.redisClient.zremrangebyscore(...execArgs);
		this.setCleaner({ executionkey, key });
	}

	async emitToSortedSet({ key, json, timestamp }) {
		try {
			const isExist = await this.isCallExist(`${json.args.call}:${json.id}`);
			if (isExist) return { error: `function with id ${json.id} already scheduled` };
			const args = [key, timestamp];
			debug(`${json.call} will be executed on ${timestamp}`);
			const jsonString = JSON.stringify(json);
			args.push(jsonString);
			this.redisClient.zadd(...args);
			this.redisClient.set(`${this._redisPrefix}:${json.args.call}:${json.id}`, true, 'PXAT', parseInt(timestamp));
			return 'scheduled';
		} catch (error) {
			debug('===> Error at emitToSortedSet <===', error);
		}
	}

	setAsExecuted({ executionkey, id, json }) {
		this.redisClient.zadd(executionkey, id, JSON.stringify(json));
	}

	async isCallExist(task) {
		return await this.redisClient.get(`${this._redisPrefix}:${task}`);
	}

	async delay(time) {
		return new Promise((resolve, _) => {
			this.timer.setTimeout(() => { resolve(true); }, '', time)
		})
	}

	async delayClean(time) {
		return new Promise((resolve, _) => {
			this.cleanerTimer.setTimeout(() => { resolve(true); }, '', time)
		})
	}

}