const path = require('path');
const { Worker } = require('worker_threads');
const debug = require("debug")("Ion-SortedSeg:Consumer");

module.exports = class Consumer {
	constructor({ url, key, executionkey, timestamp, segmantDuration, keepAlive = false, maxRunRetries = 3, onMessage = () => { }, onError = () => { }, onClose = () => { } }) {

		this.m_url = url;
		this.m_key = key;
		this.m_timestamp = timestamp;
		this.m_executionkey = executionkey;

		this.m_segmantDuration = segmantDuration;
		this.m_keepAlive = keepAlive;
		this.m_maxRunRetries = maxRunRetries;
		this.m_onMessage = onMessage;
		this.m_onError = onError;
		this.m_onClose = onClose;

		this.m_consumingWorker = null;
		this.m_forcedToStop = false;
		this.m_fork();
	}

	/** is duplicate for `close` to deprecate the close function to match the naming conventions for pup/sub */
	async stop() {
		this.m_forcedToStop = true;
		return await this.m_consumingWorker.terminate();
	}

	m_faultHandler() {
		if (this.m_keepAlive && !this.m_forcedToStop && this.m_maxRunRetries--)
			setTimeout(() => { this.m_fork(); }, 1000);
	}

	close() {
		this.m_forcedToStop = true;
		this.m_consumingWorker.terminate();
	}

	m_getWorkerData() {
		return {
			url: this.m_url, key: this.m_key, executionkey: this.m_executionkey, timestamp: this.m_timestamp, segmantDuration: this.m_segmantDuration,
		};
	}

	m_fork() {
		this.m_consumingWorker = new Worker(path.resolve(__dirname, './consuming-thread.js'), {
			env: { DEBUG: process.env.DEBUG, DEBUG_COLORS: 'true' },
			workerData: this.m_getWorkerData(),

		});

		this.m_consumingWorker.on('message', this.m_onMessage);

		this.m_consumingWorker.on('error', (error) => {
			console.error('error', error);
			this.m_faultHandler();
			this.m_onError(error);
		});

		this.m_consumingWorker.on('exit', this.m_onClose);
		this.m_consumingWorker.on("online", () => debug(`=========== Worker Thread Started with ID: ${this.m_consumingWorker.threadId} for ${this.m_prefix}:${this.m_key} ==========`));
	}
}

