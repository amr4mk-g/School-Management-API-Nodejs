const Streamer        = require('ion-streamer');  
const EventEmitter    = require('events');
const { nanoid }      = require('nanoid');
const debug           = require('debug')('ion-cortex');
const wildcard        = require('wildcard');
const NanoTimer       = require('nanotimer');
const os              = require("os");
const hostname        = os.hostname();

process.on("SIGTERM", function () {
    console.log('cortex process existed: SIGTERM')
    process.exit(1)
});

process.on("SIGINT", function () {
    console.log('cortex process existed: SIGINT');
    process.exit(1)
});

process.on('exit', () => {
    console.log('exit cortex')
    process.exit(1)
})

process.on('error', function (err) {
    console.log(err);
    process.exit(1);
});

process.on('unhandledRejection', async (reason, promise) => {
    console.log(reason);
    promise.then(e => console.log(e)).catch(e => console.log(e));
    process.exit(1);
})

process.on('uncaughtException', function (err) {
    console.log(err);
    process.exit(1);
})
module.exports = class Cortex  {
    constructor(
    {
        type,
        prefix, 
        url, 
        producerDefaultMaxLen,
        stateMaxLen,
        state,
        useHostNameAsId,
        activeDelay,
        idleDelay,
        defaultTimeout
    }){
        if(!type) throw Error('node type must be defined');
        debug(prefix, url);
        if(idleDelay && activeDelay) {
            if(isNaN(parseInt(idleDelay))) throw Error('idleDelay must be a number');
            if(isNaN(parseInt(activeDelay))) throw Error('activeDelay must be a number');
        }
        this.id                           = useHostNameAsId?hostname:nanoid();
        this.nodeType                     = type;
        this.stream                       = new Streamer({prefix , url});

        this.consumers                    = {};
        this.producers                    = {};
        this.queueListener                = {};
        this.nodes                        = {};
        // this.nodesLoad                    = {};
        this.state                        = state?state:()=>{return{}};
        this.nodeStateInterval            = '1s';
        this.stateUpdateTimer             = new NanoTimer();
        this.nodeCleanTimer               = new NanoTimer();
        this.nodeCleanerInterval          = '2s';
        this.lastUpdateMax                = 2000;
        this.nodeStateEvent               = '_node_';
        this.defaultTimeout               = defaultTimeout || 5000;
        this.produceMaxLen                = producerDefaultMaxLen || 300;
        this.stateMaxLen                  = stateMaxLen || 1000;
        this.consumePipe                  = this.stream.consumer({
            key: this.id,
            block: 0,
            keepAlive: true,
            onMessage: this.digest.bind(this),
            onError: (d)=>{debug(`got error`, d)},
            onClose: (d)=>{debug(`got close`, d)},
            idleDelay: idleDelay ? `${idleDelay}m` : null,
            activeDelay: activeDelay ? `${activeDelay}m` : null,
        });

        this.nodeStatePipe = this.stream.consumer({
            key: this.nodeStateEvent,
            block: 0,
            keepAlive: true,
            onMessage: this._nodeDigest.bind(this),
            onError: (d)=>{debug(`got error`, d)},
            onClose: (d)=>{debug(`got close`, d)},
            idleDelay: "500m",
            activeDelay: "500m",
        });

        this.producePipe   = this.stream.producer();
        
        this._nodeStateEmitter();
        this._nodeCleaner();
    }

    getNetworkInterfaces() {
        const nets = os.networkInterfaces();
        const results = {} // Or just '{}', an empty object

        for (const name of Object.keys(nets)) {
            for (const net of nets[name]) {
                // Skip over non-IPv4 and internal (i.e. 127.0.0.1) addresses
                // 'IPv4' is in Node <= 17, from 18 it's a number 4 or 6
                const familyV4Value = typeof net.family === 'string' ? 'IPv4' : 4
                if (net.family === familyV4Value && !net.internal) {
                    if (!results[name]) {
                        results[name] = [];
                    }
                    results[name].push(net.address);
                }
            }
        }
        return results
    }

    async _emitState(){
        try{
            this.producePipe.emit({
                key: this.nodeStateEvent,
                data: {
                    from: this.id,
                    type: this.nodeType,
                    state: JSON.stringify({...await this.state(), ...{
                        os: {
                            hostname,
                            cpus: os.cpus(),
                            cpuLoad: os.loadavg(),
                            network: this.getNetworkInterfaces(),
                        }
                    }}),
                },
                maxLen: this.stateMaxLen,
            });
            debug('-> state')
        } catch(err){
            debug(`unable to publish state`, err);
        }
    }

    _nodeStateEmitter(){
        
        this.stateUpdateTimer.setInterval(()=>{
            this._emitState();
        },'',this.nodeStateInterval);
   
    }

    /** remove nodes that has not been updated for nodeCleanerInterval */
    _nodeCleaner(){
        this.nodeCleanTimer.setInterval(()=>{
            debug('cleaning...')
            const now = new Date().getTime();
            Object.keys(this.nodes).forEach(tk=>{
                Object.keys(this.nodes[tk]).forEach(nk=>{
                    if((now-parseInt(this.nodes[tk][nk]._at.split('-')[0]))>this.lastUpdateMax){
                        debug('deleing host of node', nk)
                        delete this.nodes[tk][nk];
                        // const index = this.nodesLoad[tk].indexOf(nk)
                        // if (index > -1) {
                        //     this.nodesLoad[tk].splice(index, 1);
                        // }
                    }
                })
            })
        },'',this.nodeCleanerInterval);

    }
    
    /** digests nodes data */
    _nodeDigest(d){
        let m = d.value;
        if(m.type){ 
            if(!this.nodes[m.type]) this.nodes[m.type]={};
            this.nodes[m.type][m.from]={
                // id: m.from,
                _at: d.id,
                at: new Date().getTime(),
                state: JSON.parse(m.state),
            }
            // if(!this.nodesLoad[m.type])this.nodesLoad[m.type]=[];
            // if(!this.nodesLoad[m.type].includes[m.from])this.nodesLoad[m.type].unshift(m.from);
        } else {
            debug('_node_ is called without type');
        }
    }

    _getConsumerKey(call){
        let result = null;
        let keys = Object.keys(this.consumers);
        for(let i=0; i<keys.length; i++){
            
            if(wildcard(keys[i], call)){
                result = keys[i]
                break;
            } else {
                debug(`wildcard-failed to match`);
                debug(`wildcard(${keys[i]}, ${call})`);
            }
        }
        return result;
    }

    /** for processing incoming message */
    async digest(d){
        d=d.value;
        
        /** if call exists */
        if(d.call){
            /** parse if only a caller listening */
            if(d.data){
                try {
                    d.data=JSON.parse(d.data);
                }catch(err){
                    debug(`unable to parse data on digest ${d.data}`);
                    debug(err);
                }
            }
            if(d.reply){
                try {
                    d.reply = JSON.parse(d.reply);
                } catch(err){
                    debug(`unable to parse reply on digest ${d.reply}`);
                    debug(err);
                }
            } 
            /** if the message type is reply then it is possible 
             * that a local queue is waiting for response */
            if(d.type == "reply"){
                if(
                    this.queueListener[d.call] &&
                    this.queueListener[d.call][d.id]){
                    try {
                        this.queueListener[d.call][d.id](d.data);
                    } catch(err){
                        debug(err);
                    }
                    /** fullfiled no need to keep */
                    delete this.queueListener[d.call][d.id];
                    return;
                } else {
                    debug('no queue listenting for id', d.id);
                }
            } 

            /** if the incoming message 
             * event has consumer listening  */
            let consumerKey = this._getConsumerKey(d.call);
            if(consumerKey){

                /** get the default event call back */
                const cb = this.consumers[consumerKey];
                if(!cb){
                    debug(`error: cb not found for consumerKey ${consumerKey}`);
                    return;
                };
                let result = null;

                try {
                    /** 
                     * the function it self can return soft error
                     * by returning object with .error prop as string
                     * or throw error and error will be captured 
                     * by the catch block
                     * */
                    cb(d.data, {event: d.call}, function(result){
                        debug('call back triggered');
                        /** if the message 
                         * is asking for reply to be sent back */
                        if(d.reply && d.reply.to){
                            this._reply({
                                id: d.id || null,
                                to: d.reply.to,
                                call: d.reply.call,
                                data: result,
                            });
                        } else {
                            debug('failed to reply as no reply.to available')
                        }
                    }.bind(this));
                } catch(err){
                    result = {};
                    result.error = err.toString();
                    debug(`result.error`, result.error);
                }
                 
                /** <<WAS HERE >> */
            } else {
                debug(`ðŸ”• no listeners for ${d.call}`);
                if(d.reply && d.reply.to){
                    this._reply({
                        id: d.id || null,
                        to: d.reply.to,
                        call: d.reply.call,
                        data: {error:`EVENT ${d.call} NOT FOUND`},
                    });
                }
            }
        }else {
            debug('received message without call')
        } 
             
    }

    between({min, max}) {  
        return Math.floor(
          Math.random() * (max - min) + min
        )
    }

    eventId(event){
        if(!event)throw Error('event name not found');
        return event;
    }
    
    // AsyncEmitToAllOf(args) {
    //     return new Promise((resolve, reject) => {
    //         this.emitToAllOf(args, (d) => {
    //             resolve(d);
    //         })
    //     })
    // }

    // AsyncEmitToOthersOf(args) {
    //     return new Promise((resolve, reject) => {
    //         this.emitToOthersOf(args, (d) => {
    //             resolve(d);
    //         })
    //     })
    // }

    AsyncEmitToOneOf(args) {
        return new Promise((resolve, reject) => {
            try {
                this.emitToOneOf(args, (d) => {
                    resolve(d);
                })
            } catch (err) {
                console.log(err);
                reject({ error: true });
            }
        })
    }

    AsyncEmit(args){
        return new Promise((resolve, reject)=>{
            try{
                this.emit(args, (d)=>{
                    resolve(d);
                })
            } catch(e) {
                console.log(err);
                reject({ error: true });
            }
        })
    }

    emitToOneOf({type, call, data, args, reply}, cb, timeout){
        if(!type) throw Error('node type must be defined');
        data = data || args;
        let to = null;
        if(this.nodes[type]){
            /** loadbalancing */
            let nodesKeys = Object.keys(this.nodes[type]);
            let to = nodesKeys[this.between({min:0, max: nodesKeys.length-1})];
            if(to){
                this.emit({to, call, data, reply}, cb, timeout);
            } else {
                if(cb)cb({error: 'NO_NODES_FOUND'});
            }
        } else {
            if(cb)cb({error: 'NO_NODES_FOUND'});
        }
    }

    emitToAllOf({type, call, data, args, reply}, cb, timeout){
        if(!type) throw Error('node type must be defined');
        data = data || args;
        if(this.nodes[type] && Object.keys(this.nodes[type]).length>0){
            let nodeKeys = Object.keys(this.nodes[type]);
            for(let i=0; i<nodeKeys.length; i++){
                this.emit({to: nodeKeys[i], call, data, reply}, cb, timeout);
            }
        } else {
            if(cb)cb({error: 'NO_NODES_FOUND'});
        }
    }

    emitToOthersOf({type, call, data, args, reply}, cb, timeout){
        if(!type) throw Error('node type must be defined');
        data = data || args;
        if(this.nodes[type] && Object.keys(this.nodes[type]).length>0){
            let nodeKeys = Object.keys(this.nodes[type]);
            for(let i=0; i<nodeKeys.length; i++){
                if(`${this.id}` == `${nodeKeys[i]}`) {
                    console.log('Node skip self-calling ')
                }else{
                    this.emit({to: nodeKeys[i], call, data, reply}, cb, timeout);
                }
            }
        } else {
            if(cb)cb({error: 'NO_NODES_FOUND'});
        }
    }

    /** reply call shouldn't contain a reply */
    _reply({to, id, call, data}){
        this.emit({to, id, call, data, type: 'reply'})
    }

    emit({to, id, call, data, reply, args, type}, cb, timeout){
        id = id || nanoid();
        data = data || args;
        if(cb){

            reply = {
                to: this.id,
                call: `${call}_reply_`,
            }
     
            if(!this.queueListener[reply.call]){
                this.queueListener[reply.call]= {};
            }
            this.queueListener[reply.call][id] = cb;
            debug(`recorded queue listener for id`, id);
            setTimeout(()=>{
                /** 
                 * if it is still waiting in queue for all that 
                 * time deleted 
                 */
                if(this.queueListener[reply.call][id]){
                    cb({error: 'TIMEOUT'});
                }
                
            }, timeout||this.defaultTimeout);
        }
        
        data = {from: this.id, call, id, data: data?JSON.stringify(data):{}, reply: reply?JSON.stringify(reply):null, type: type?type:'fire'};
        debug(`-> msg`);
        this.producePipe.emit({
            key: to,
            data,
            maxLen: this.produceMaxLen,
        })
    }

    AsyncEmitToOneOfFar(args) {
        return new Promise((resolve, reject) => {
            try {
                this.emitToOneOfFar(args, (d) => {
                    resolve(d);
                })
            } catch (err) {
                console.log(err);
                reject({ error: true });
            }
        })
    }

    emitToOneOfFar({type, call, data, args, reply}, cb, timeout){
        if(!type) throw Error('node type must be defined');
        data = data || args;
        let to = null;
        if(this.nodes[type]){
            /** loadbalancing */

            let nodesKeys = Object.keys(this.nodes[type]).filter(
                (node) => this.nodes[type][node].state.os.hostname != hostname
            );
            let to = nodesKeys[this.between({min:0, max: nodesKeys.length-1})];
            if(to){
                this.emit({to, call, data, reply}, cb, timeout);
            } else {
                if(cb)cb({error: 'NO_NODES_FOUND'});
            }
        } else {
            if(cb)cb({error: 'NO_NODES_FOUND'});
        }
    }

    emitToAllOfFar({type, call, data, args, reply}, cb, timeout){
        if(!type) throw Error('node type must be defined');
        data = data || args;
        if(this.nodes[type] && Object.keys(this.nodes[type]).length>0){
            let nodeKeys = Object.keys(this.nodes[type]);
            for(let i=0; i<nodeKeys.length; i++){
                if(this.nodes[type][nodeKeys[i]].state.os.hostname == hostname) {
                    console.log('Node skip self-calling machine')
                }else{
                    this.emit({to: nodeKeys[i], call, data, reply}, cb, timeout);
                }
            }
        } else {
            if(cb)cb({error: 'NO_NODES_FOUND'});
        }
    }

    /** sub to a specific event and register in consumers */
    sub(event, cb){
        event = this.eventId(event);
        this.consumers[event] = cb;
    }

    unsub(event){
        event = this.eventId(event);
        if(this.consumers[event]) delete this.consumers[event];
    }

}